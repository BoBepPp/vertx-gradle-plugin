import org.vertx.java.core.Handler
import org.vertx.java.platform.PlatformLocator
import org.vertx.java.platform.impl.ModuleClassLoader

/*
 * Copyright 2012 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
  Usage:

  ./gradlew task_name

  (or gradlew.bat task_name if you have the misfortune to have to use Windows)

  If no task name is specified then the default task 'assemble' is run

  Task names are:

  idea - generate a skeleton IntelliJ IDEA project

  eclipse - generate a skeleton Eclipse IDE project

  assemble - builds the outputs, by default this is the module zip file. It can also include a jar file if produceJar
            in gradle.properties is set to true. Outputs are created in build/libs.
            if pullInDeps in gradle.properties is set to 'true' then the modules dependencies will be
            automatically pulled into a nested mods directory inside the module during the build

  copyMod - builds and copies the module to the local 'mods' directory so you can execute vertx runmod (etc)
            directly from the command line

  modZip - creates the module zip into build/libs

  clean - cleans everything up

  test - runs the tests. An nice html test report is created in build/reports/tests (index.html)

  runMod - runs the module. This is similar to executing vertx runmod from the command line except that it does
           not use the version of Vert.x installed and on the PATH to run it. Instead it uses the version of Vert.x
           that the module was compiled and tested against.

  pullInDeps - pulls in all dependencies of the module into a nested module directory

  uploadArchives - upload the module zip file (and jar if one has been created) to Nexus. You will need to
                   configure sonatypeUsername and sonatypePassword in ~/.gradle/gradle.properties.

  install - install any jars produced to the local Maven repository (.m2)
*/

// Convenient and informative logging
allprojects {
  ext.info = { String message ->
    if (message){
      println "[$project.name] $message"
    }
  }
}

info "Beginning Configuration\n"

subprojects {
  project.ext.configureAsModule = {
    info "Applying Module Language Plugins"
    apply plugin: 'java'
    apply plugin: 'groovy'
    apply plugin: 'idea'
    apply plugin: 'eclipse'

    info "Loading vertx.properties and vertx.gradle"
    // We load extra properties from vertx.properties into the project
    loadProperties(project)

    // And then apply the project vertx.gradle script
    apply from: "$project.projectDir/$VERTX_GRADLE_FILENAME"

    // maven build script is applied after vertx.gradle as it needs to
    // find the configurePom method that is defined in vertx.gradle
    // if configurePom is not defined, the script will not be evaluated
    if(project.hasProperty('configurePom')){
      info "Maven configuration is available"
      apply from: "$rootDir/gradle/maven.gradle"
    }

    defaultTasks = ['assemble']

    sourceCompatibility = '1.7'
    targetCompatibility = '1.7'

    project.ext.moduleName = "maven:$group:$artifact:$version"

    if (produceJar == 'false') {
      info "Jars have been disabled for this module."
      jar.enabled = false
      assert configurations.archives.artifacts.removeAll { it.file == jar.archivePath }
    }

    configurations {
      provided
      testCompile.extendsFrom provided
    }

    repositories {
      mavenLocal()
      maven { url 'https://oss.sonatype.org/content/repositories/snapshots' }
      mavenCentral()
    }

    dependencies {
      provided "io.vertx:vertx-core:$vertxVersion"
      provided "io.vertx:vertx-platform:$vertxVersion"
      testCompile "junit:junit:$junitVersion"
      testCompile "io.vertx:testtools:$toolsVersion"
    }

    sourceSets {
      main {
        compileClasspath = compileClasspath + configurations.provided
      }
    }

    info "Adding Tasks"
    task copyMod( type:Copy, dependsOn: 'classes', description: 'Assemble the module into the local mods directory' ) {
      into "mods/$project.moduleName"
      from compileJava
      from 'src/main/resources'
      into( 'lib' ) {
        from configurations.compile
      }
    }

    task modZip( type: Zip, dependsOn: 'pullInDeps', description: 'Package the module .zip file') {
      group = 'vert.x'
      description = "Assembles a vert.x module"
      destinationDir = project.file('build/libs')
      archiveName = "${artifact}-${version}" + ".zip"
      from copyMod
    }

    task pullInDeps(dependsOn: copyMod, description: 'Pull in all the module dependencies for the module into the nested mods directory') << {
      if (pullInDeps == 'true') {
        def pm = PlatformLocator.factory.createPlatformManager()
        System.out.println("Pulling in dependencies for module " + moduleName + " Please wait")
        pm.pullInDependencies(moduleName)
        System.out.println("Dependencies pulled into mods directory of module")
      }
    }

    info "Performing common configuration"
    artifacts {
      archives modZip
    }

    task cleanModsDir(type: Delete) {
      delete 'mods'
    }

    clean {
      dependsOn cleanModsDir
    }

    test {
      dependsOn copyMod

      // Make sure tests are always run!
      outputs.upToDateWhen { false }

      // Show output
      testLogging.showStandardStreams = true

      testLogging { exceptionFormat "full" }
    }
  }


  // Ignore this project if it is not one of our vertx modules
  if(!isModuleProject(project)){
    info "Not a vert.x module. Ignoring.\n"
  }else {
    info "Is a vert.x module."
    project.configureAsModule()
    info("Configuration Complete\n")
  }
}

// Root Project Configuration

// This sets up the classpath for the script itself
buildscript {

  repositories {
    mavenLocal()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots' }
    mavenCentral()
  }

  dependencies {
    classpath "io.vertx:vertx-core:$vertxVersion"
    classpath "io.vertx:vertx-platform:$vertxVersion"
  }
}


tasks.addRule("Pattern: run<moduleName>"){ String taskName ->
  if(taskName.startsWith('run')){
    task(taskName) << {
      def moduleName = taskName.replaceFirst('run','')
    }
  }
}

/*
task runMod(dependsOn: copyMod, description: 'Run the module using all the build dependencies (not using installed vertx') << {
  ModuleClassLoader.reverseLoadOrder = false
  def pm = PlatformLocator.factory.createPlatformManager()
  pm.deployModule(moduleName, null, 1, new Handler<String>() {
    public void handle(String deploymentID) {
      System.out.println("CTRL-C to stop server")
    }
  });
  Thread.sleep(Long.MAX_VALUE);
}
*/

// Helper Functions
def isModuleProject(Project project){
  def result = new File("$project.projectDir/$VERTX_GRADLE_FILENAME").canRead()
  return result
}

def loadProperties(Project project) {
  def config = new Properties()
  def propFile = new File("$project.projectDir/$VERTX_PROPERTIES_FILENAME")

  if(!propFile.canRead()){
    return
  }

  config.load(new FileInputStream(propFile))
  for (Map.Entry property in config) {
    project.ext[property.key] = property.value;
  }
}